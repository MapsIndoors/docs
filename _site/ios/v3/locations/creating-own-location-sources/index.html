<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="/assets/style.css">
    <title>Document</title>
  </head>
  <body>
    <section class="container">
      
  <nav>
    <h2>iOS v3</h2>
    
    <ul class="sidebar-nav"><li><a href="/ios/v3/getting-started/">Getting started</a></li>
<li class="bold"><a href="/ios/v3/mapsindoors/">MapsIndoors</a><ul><li><a href="/ios/v3/mapsindoors/handling-marker-selections/">Handling marker selections and other user events</a></li>
<li><a href="/ios/v3/mapsindoors/getting-marker-from-location/">Getting a marker from a location and vice versa</a></li>
<li><a href="/ios/v3/mapsindoors/getting-polygon-from-location/">Getting a polygon from a location</a></li>
<li><a href="/ios/v3/mapsindoors/blue-dot/">Show the user's location aka. Blue Dot</a></li>
<li><a href="/ios/v3/mapsindoors/create-custom-ui/">Create custom UI</a></li></ul></li>
<li class="bold"><a href="/ios/v3/locations/">Locations</a><ul><li><a href="/ios/v3/locations/get-details-for-selected-location/">Show details for selected Location</a></li>
<li><a href="/ios/v3/locations/working-grouping/">Working with Location Grouping (Clustering)</a></li>
<li class="active"><a href="/ios/v3/locations/creating-own-location-sources/">Creating your own Location Sources</a></li></ul></li>
<li class="bold"><a href="/ios/v3/directions/">Directions</a><ul><li><a href="/ios/v3/directions/directions-wayfinding-instructions/">Get Directions and Show Wayfinding Instructions</a></li>
<li><a href="/ios/v3/directions/display-route-on-map/">Display Route on map</a></li>
<li><a href="/ios/v3/directions/directions-result-map/">Get Directions and Show the Result on a Map</a></li>
<li><a href="/ios/v3/directions/working-with-directions-settings/">Subscribe to floor changes in the rendering</a></li>
<li><a href="/ios/v3/directions/working-with-events/">Working with Events</a></li>
<li><a href="/ios/v3/directions/subscribe-to-floor-changes/">Subscribe to floor changes in the rendering</a></li></ul></li>
<li class="bold"><a href="/ios/v3/map-styling/">Map Styling</a><ul><li><a href="/ios/v3/map-styling/work-with-display-settings/">Working with Display Settings</a></li></ul></li>
<li class="bold"><a href="/ios/v3/search/">Search</a><ul><li><a href="/ios/v3/search/search-experience/">Create a search experience with MapsIndoors</a></li>
<li><a href="/ios/v3/search/filter-locations-on-map-by-search-query/">Filter Locations on map by search query</a></li></ul></li>
<li><a href="/ios/v3/offline/">Download and bundle offline content</a></li>
<li><a href="/ios/v3/changelog/">Changelog</a></li></ul>
  </nav>

      <main>
        <p>In this tutorial we will show how you can build a custom Location Source, representing locations of people. The people locations will be served from a mocked list in the source and displayed on a map in a view controller.</p>
<p>We will start by creating our implementation of a location source.</p>
<p>Create a class <code>PeopleLocationsDataSource</code> that inherits from NSObject and implements <code>MPLocationSource</code>.</p>
<pre><code class="language-swift">class PeopleLocationSource : NSObject, MPLocationSource {
</code></pre>
<p>Add some member variables to <code>PeopleLocationsDataSource</code>.</p>
<ul>
<li><code>observers</code>: The observer objects that we will notify about changes</li>
<li><code>locationUpdates</code>: A list of MPLocationUpdate - the MPLocation builders</li>
<li><code>locationPoints</code>: A list of MPPoint - the positions that we will mock</li>
<li><code>locationDirs</code>: A list of directions - the walking direction for each &quot;person&quot;</li>
<li><code>queue</code>: A backround queue</li>
<li><code>numberOfPeople</code>: The number of people to mock</li>
</ul>
<pre><code class="language-swift">private var observers = [MPLocationsObserver]()
private var locationUpdates = [MPLocationUpdate]()
private var locationPoints = [MPPoint]()
private var locationDirs = [Double]()
private let queue = DispatchQueue.init(label: &quot;UpdatePositions&quot;)
private let numberOfPeople = 100
</code></pre>
<p>Create a method called <code>getRandomPoint</code> that simply just returns a random point (here within proximity of the demo venue)</p>
<pre><code class="language-swift">func getRandomPoint() -&gt; MPPoint {
    let lat = 57.058037 + Double.random(in: -0.0004 ..&lt; 0.0004)
    let lng = 9.950572 + Double.random(in: -0.0004 ..&lt; 0.0004)
    return MPPoint.init(lat: lat, lon: lng, zValue: 1)
}
</code></pre>
<p>Create a method called <code>createPeople</code> that takes a type string. Iterate numberOfPeople and for each iteration create:</p>
<ul>
<li>An MPLocationUpdate with an id and a source (self)</li>
<li>A type - later used to style the location</li>
<li>A floor</li>
<li>A random point and initial direction for the person</li>
</ul>
<pre><code class="language-swift">func createPeople(_ type: String) {
    for locId in 0 ..&lt; numberOfPeople {

        let locationUpdate = MPLocationUpdate.init(id: locId, from: self)

        locationUpdate.type = type
        locationUpdate.addPropertyValue(&quot;John Doe #\(locId)&quot;, forKey: MPLocationFieldName)
        locationUpdate.floor = 1
        let p = getRandomPoint()
        locationPoints.append(p)
        locationDirs.append(Double.random(in: 0 ..&lt; 360))
        locationUpdate.position = p.getCoordinate()
        locationUpdates.append(locationUpdate)

    }
}
</code></pre>
<p>Create a method called <code>updatePositions</code>. Iterate numberOfPeople again and for each iteration:</p>
<ul>
<li>Get the corresponding MPLocationUpdate</li>
<li>Set a new position using Google Maps' offsetting function</li>
<li>Save a new heading and position</li>
<li>Generate MPLocation from the MPLocationUpdate
After iteration, notify each observer about the updates locations</li>
</ul>
<pre><code class="language-swift">func updatePositions() {
    var updatedLocations = [MPLocation]()
    for locId in 0 ..&lt; numberOfPeople {
        let locationUpdate = locationUpdates[locId]
        let newPos = GMSGeometryOffset(locationPoints[locId].getCoordinate(), 0.5, locationDirs[locId])
        locationUpdate.position = newPos
        locationDirs[locId] = locationDirs[locId] + Double.random(in: -22 ..&lt; 22)
        locationPoints[locId] = MPPoint.init(lat: newPos.latitude, lon: newPos.longitude)
        updatedLocations.append(locationUpdate.location())
    }
    for observer in observers {
        observer.onLocationsUpdate(updatedLocations, source: self)
    }
    queue.asyncAfter(deadline: .now() + 0.5) {
        self.updatePositions()
    }
}
</code></pre>
<p>Create a method called <code>startMockingPositions</code> that simply just calls <code>updatePositions</code> in the future.</p>
<pre><code class="language-swift">func startMockingPositions() {
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        self.updatePositions()
    }
}
</code></pre>
<p>Create an initialiser that takes a type string. Call <code>createPeople</code> and <code>startMockingPositions</code>.</p>
<pre><code class="language-swift">convenience init(type:String) {

    self.init()

    createPeople(type)

    startMockingPositions()
}
</code></pre>
<p>Implement the MPLocationSource method <code>getAllLocations</code>. For this demo just return an empty array as each update will also contain the full list of locations.</p>
<pre><code class="language-swift">func getLocations() -&gt; [MPLocation] {
    return []
}
</code></pre>
<p>Implement the MPLocationSource method <code>addLocationObserver</code>.</p>
<pre><code class="language-swift">func add(_ observer: MPLocationsObserver) {
    observers.append(observer)
}
</code></pre>
<p>Implement the MPLocationSource method <code>removeLocationObserver</code>.</p>
<pre><code class="language-swift">func remove(_ observer: MPLocationsObserver) {
    observers = observers.filter({ (obsvr) -&gt; Bool in
        return obsvr === observer
    })
}
</code></pre>
<p>Implement the MPLocationSource method <code>sourceStatus</code>.</p>
<pre><code class="language-swift">func status() -&gt; MPLocationSourceStatus {
    return .available
}
</code></pre>
<p>Implement the MPLocationSource method <code>sourceIdentifier</code>.</p>
<pre><code class="language-swift">func sourceId() -&gt; Int32 {
    return 0;
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Location%20Sources/PeopleLocationSource.swift">See the sample in PeopleLocationSource.swift</a></p>
<h2>Create another location source that mocks the availability of meeting rooms or work desks</h2>
<p>This location source rely on MapsIndoors data, so we will consume the locations of <code>MPMapsIndoorsLocationSource</code> and relay them as this source's own locations. Thus we need to observe the <code>MPMapsIndoorsLocationSource</code> and act as a LocationSource at the same time.</p>
<p>Create a class <code>RoomAvailabilitySource</code> that inherits from NSObject and implements <code>MPLocationSource</code> and <code>MPLocationsObserver</code>.</p>
<pre><code class="language-swift">class RoomAvailabilitySource : NSObject, MPLocationSource, MPLocationsObserver {
</code></pre>
<p>Add some member variables to <code>RoomAvailabilitySource</code>.</p>
<ul>
<li><code>observers</code>: The observer objects that we will notify about changes</li>
<li><code>locationUpdates</code>: A dictionary of reusable <code>MPLocationUpdate</code> models</li>
<li><code>miMapsIndoorsSource</code>: The MapsIndoors source to observe</li>
</ul>
<pre><code class="language-swift">private var observers = [MPLocationsObserver]()
private var locationUpdates = Dictionary&lt;String, MPLocationUpdate&gt;()
private let miMapsIndoorsSource:MPLocationSource = MPMapsIndoorsLocationSource()
</code></pre>
<p>In the initialiser, add this instance as observer for The MapsIndoors source.</p>
<pre><code class="language-swift">override init() {
    super.init()
    self.miMapsIndoorsSource.add(self)
}
</code></pre>
<p>Create a method <code>updateIconForLocation</code> that takes a location and grabs or creates a location update object. Randomly modify the icon of that location so it looks occupied.</p>
<pre><code class="language-swift">func updateIconForLocation(location:MPLocation) -&gt; MPLocationUpdate? {
    if locationUpdates[location.locationId!] == nil {
        locationUpdates[location.locationId!] = MPLocationUpdate.init(location: location)
    }
    let locUpdate = locationUpdates[location.locationId!]

    if (Int.random(in: 0...1) == 0) {
        locUpdate?.icon = UIImage(named: &quot;closed&quot;)!
    }
    return locUpdate
}
</code></pre>
<p>Create a method <code>updateLocations</code> that runs through a list of locations add creates location update objects.</p>
<pre><code class="language-swift">func updateLocations(locations:[MPLocation]) -&gt; [MPLocation] {

    var updatedLocations = [MPLocation]()

    for location in locations {
        if let locUpdate = updateIconForLocation(location: location) {
            updatedLocations.append(locUpdate.location())
        }
    }

    return updatedLocations
}
</code></pre>
<p>Implement the MPLocationSource method <code>getLocations</code>. For this demo just return the full list of MapsIndoors' locations.</p>
<pre><code class="language-swift">func getLocations() -&gt; [MPLocation] {
    return miMapsIndoorsSource.getLocations()
}
</code></pre>
<p>Implement the MPLocationSource method <code>addLocationObserver</code>.</p>
<pre><code class="language-swift">func add(_ observer: MPLocationsObserver) {
    observers.append(observer)
}
</code></pre>
<p>Implement the MPLocationSource method <code>removeLocationObserver</code>.</p>
<pre><code class="language-swift">func remove(_ observer: MPLocationsObserver) {
    observers = observers.filter({ (obsvr) -&gt; Bool in
        return obsvr !== observer
    })
}
</code></pre>
<p>Implement the MPLocationSource method <code>sourceStatus</code>.</p>
<pre><code class="language-swift">func status() -&gt; MPLocationSourceStatus {
    return .available
}
</code></pre>
<p>Implement the MPLocationSource method <code>sourceIdentifier</code>.</p>
<pre><code class="language-swift">func sourceId() -&gt; Int32 {
    return 2;
}
</code></pre>
<p>Relay <code>onLocationsDelete</code> events to this sources own observers.</p>
<pre><code class="language-swift">func onLocationsDelete(_ locations: [String], source: MPLocationSource) {
    for obsvr in observers {
        obsvr.onLocationsDelete(locations, source: self)
    }
}
</code></pre>
<p>In <code>onLocationsUpdate</code> create new modified locations objects and call the observers.</p>
<pre><code class="language-swift">func onLocationsUpdate(_ locationUpdates: [MPLocation], source: MPLocationSource) {
    let locations = updateLocations(locations: locationUpdates)
    for obsvr in observers {
        obsvr.onLocationsUpdate(locations, source: self)
    }
}
</code></pre>
<p>Relay <code>onStatusChange</code> events to this sources own observers.</p>
<pre><code class="language-swift">func onStatusChange(_ status: MPLocationSourceStatus, source: MPLocationSource) {
    for obsvr in observers {
        obsvr.onStatusChange(status, source: self)
    }
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Location%20Sources/RoomAvailabilitySource.swift">See the sample in RoomAvailabilitySource.swift</a></p>
<h2>Create a view controller displaying a map that shows the mocked people locations and the mocked room availability on top of a MapsIndoors map</h2>
<p>Create a class <code>LocationSourcesController</code> that inherits from <code>UIViewController</code>.</p>
<pre><code class="language-swift">class LocationSourcesController: UIViewController {
</code></pre>
<p>Add a <code>GMSMapView</code> and a <code>MPMapControl</code> to the class</p>
<pre><code class="language-swift">var map: GMSMapView? = nil
var mapControl: MPMapControl? = nil

override func viewDidLoad() {

    super.viewDidLoad()
</code></pre>
<p>Inside <code>viewDidLoad</code>, register the sources <code>PeopleLocationSource</code> and <code>RoomAvailabilitySource</code></p>
<pre><code class="language-swift">MapsIndoors.register([
    PeopleLocationSource.init(type: &quot;People&quot;),
    RoomAvailabilitySource.init()
])
</code></pre>
<p>Inside <code>viewDidLoad</code>, setup the map so that it shows the demo venue and initialise mapControl</p>
<pre><code class="language-swift">self.map = GMSMapView.init(frame: CGRect.zero)
self.view = self.map
self.map?.camera = .camera(withLatitude: 57.057964, longitude: 9.9504112, zoom: 20)
self.mapControl = MPMapControl.init(map: self.map!)
</code></pre>
<p>Inside <code>viewDidLoad</code>, setup a display setting that refers to the type of locations that your people location source operates with.</p>
<pre><code class="language-swift">let dr = MPLocationDisplayRule.init(name: &quot;People&quot;, andIcon: UIImage.init(named: &quot;user.png&quot;), andZoomLevelOn: 17)!
self.mapControl?.add(dr)
</code></pre>
<p>Optionally, when you leave this controller. Remove the custom Location Source by adding back the <code>MPMapsIndoorsLocationSource</code> as the only one.</p>
<pre><code class="language-swift">override func viewDidDisappear(_ animated: Bool) {
    MapsIndoors.register([MPMapsIndoorsLocationSource()])
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Location%20Sources/LocationSourcesController.swift">See the sample in LocationSourcesController.swift</a></p>

      </main>
    </section>
  </body>
</html>
