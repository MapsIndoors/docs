<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
  </head>
  <body>
    
  <nav>
    <h2>iOS v3</h2>
    
    <ul class="sidebar-nav"><li><a href="/ios/v3/getting-started/">Getting started</a></li>
<li class="bold"><a href="/ios/v3/mapsindoors/">MapsIndoors</a><ul><li><a href="/ios/v3/mapsindoors/handling-marker-selections/">Handling marker selections and other user events</a></li>
<li><a href="/ios/v3/mapsindoors/getting-marker-from-location/">Getting a marker from a location and vice versa</a></li>
<li><a href="/ios/v3/mapsindoors/getting-polygon-from-location/">Getting a polygon from a location</a></li>
<li><a href="/ios/v3/mapsindoors/blue-dot/">Show the user's location aka. Blue Dot</a></li>
<li><a href="/ios/v3/mapsindoors/create-custom-ui/">Create custom UI</a></li></ul></li>
<li class="bold"><a href="/ios/v3/locations/">Locations</a><ul><li><a href="/ios/v3/locations/get-details-for-selected-location/">Show details for selected Location</a></li>
<li><a href="/ios/v3/locations/working-grouping/">Working with Location Grouping (Clustering)</a></li>
<li><a href="/ios/v3/locations/creating-own-location-sources/">Creating your own Location Sources</a></li></ul></li>
<li class="bold"><a href="/ios/v3/directions/">Directions</a><ul><li class="active"><a href="/ios/v3/directions/directions-wayfinding-instructions/">Get Directions and Show Wayfinding Instructions</a></li>
<li><a href="/ios/v3/directions/display-route-on-map/">Display Route on map</a></li>
<li><a href="/ios/v3/directions/directions-result-map/">Get Directions and Show the Result on a Map</a></li>
<li><a href="/ios/v3/directions/working-with-directions-settings/">Subscribe to floor changes in the rendering</a></li>
<li><a href="/ios/v3/directions/working-with-events/">Working with Events</a></li>
<li><a href="/ios/v3/directions/subscribe-to-floor-changes/">Subscribe to floor changes in the rendering</a></li></ul></li>
<li class="bold"><a href="/ios/v3/map-styling/">Map Styling</a><ul><li><a href="/ios/v3/map-styling/work-with-display-settings/">Working with Display Settings</a></li></ul></li>
<li class="bold"><a href="/ios/v3/search/">Search</a><ul><li><a href="/ios/v3/search/search-experience/">Create a search experience with MapsIndoors</a></li>
<li><a href="/ios/v3/search/filter-locations-on-map-by-search-query/">Filter Locations on map by search query</a></li></ul></li>
<li><a href="/ios/v3/offline/">Download and bundle offline content</a></li>
<li><a href="/ios/v3/changelog/">Changelog</a></li></ul>
  </nav>

    <main>
      <p>In this tutorial we will show how to work with the route model returned from a directions service call. We will also show how you can utilize interaction between the route rendering on the map and textual instructions showed in another view.</p>
<p>We will start by creating our implementation of a custom <code>UICollectionViewCell</code> that will hold the instructions for a single segment of a route.</p>
<p>In the route model there are some text properties that we will interpret as enum values, so start out by creating enums <code>RouteContext</code> describing whether we are outside or inside and <code>WayType</code> describing what kind of facility we are walking/travelling through.</p>
<pre><code class="language-swift">enum RouteContext : String
{
    case insideBuilding = &quot;InsideBuilding&quot;
    case outsideOnVenue = &quot;OutsideOnVenue&quot;
}

enum WayType : String
{
    case stairs = &quot;steps&quot;
    case elevator = &quot;elevator&quot;
    case travellator = &quot;travellator&quot;
    case escalator = &quot;escalator&quot;
    case footway = &quot;footway&quot;
    case residential = &quot;residential&quot;
}

</code></pre>
<p>Create a subclass of <code>UICollectionViewCell</code> called <code>RouteSegmentView</code></p>
<pre><code class="language-swift">class RouteSegmentView : UITableViewCell {
</code></pre>
<p>Add a property called <code>route</code> that holds entire route model.</p>
<pre><code class="language-swift">private var route:MPRoute = MPRoute()
</code></pre>
<p>Add a property called <code>segment</code> that holds the actual segment of <code>route</code> that this view is going to reflect.</p>
<pre><code class="language-swift">private var segment:MPRouteSegmentPath = MPRouteSegmentPath()
</code></pre>
<p>Add a method called <code>renderRouteInstructions</code> that updates <code>segment</code> and <code>route</code>. Call the method <code>updateViews</code> when set.</p>
<pre><code class="language-swift">func renderRouteInstructions(_ route:MPRoute, for segment:MPRouteSegmentPath) {
    self.route = route
    self.segment = segment
    updateViews()
}
</code></pre>
<h2>Helper methods</h2>
<p>We will need some helper methods. First create a method that can get us the previous step for later comparison.</p>
<pre><code class="language-swift">fileprivate func getPreviousStep(_ stepIndex: Int, _ legIndex: Int, _ route: MPRoute) -&gt; MPRouteStep? {

    var previousStep: MPRouteStep?
    if stepIndex-1 &lt; 0 {
        if segment.legIndex-1 &gt;= 0 {
            let previousLeg = route.legs?[segment.legIndex-1] as? MPRouteLeg
            previousStep = previousLeg?.steps?.lastObject as? MPRouteStep
        }
    } else if let leg = route.legs?[segment.legIndex] as? MPRouteLeg {
        previousStep = leg.steps?[stepIndex-1] as? MPRouteStep
    }
    return previousStep
}
</code></pre>
<p>Create a method <code>getOutsideInsideInstructions</code> that can get us instructions for walking inside or out of a building. This is determined by the <code>routeContext</code> property of an <code>MPRouteStep</code></p>
<pre><code class="language-swift">fileprivate func getOutsideInsideInstructions(_ previousStep: MPRouteStep, _ currentStep: MPRouteStep) -&gt; String? {
    var instructions:String?
    if let previousContext = previousStep.routeContext {
        if previousContext != currentStep.routeContext {

            let ctx = RouteContext.init(rawValue: currentStep.routeContext ?? &quot;&quot;)

            if ctx == .insideBuilding {
                instructions = &quot;Walk inside&quot;
            } else if ctx == .outsideOnVenue {
                instructions = &quot;Walk outside&quot;
            }

        }
    }
    return instructions
}
</code></pre>
<p>Create a method <code>getElevationInstructions</code> that can get us instructions for taking the stairs or elevator to another floor. This is determined by the <code>highway</code> and <code>end_location.zLevel</code> properties of a <code>MPRouteStep</code>.</p>
<pre><code class="language-swift">fileprivate func getElevationInstructions(_ currentStep: MPRouteStep) -&gt; String? {
    var instructions:String?
    if currentStep.start_location?.zLevel?.intValue != currentStep.end_location?.zLevel?.intValue {

        let floor = currentStep.end_location?.floor_name ?? &quot;&quot;
        let wayType = WayType.init(rawValue: currentStep.highway ?? &quot;&quot;) ?? .footway

        switch (wayType) {
            case .elevator, .escalator, .stairs, .travellator:
                instructions = &quot;Take the \(wayType.rawValue) to floor \(floor)&quot;
            default:
                instructions = &quot;Go to level \(floor)&quot;
        }
    }
    return instructions
}
</code></pre>
<p>Create a method <code>getDefaultInstructions</code> that can get us information about the default instructions in a route step. In some cases they are html formatted, so we need to pass it through an interpreter.</p>
<pre><code class="language-swift">fileprivate func getDefaultInstructions(_ currentStep: MPRouteStep) -&gt; String? {
    if let html = currentStep.html_instructions {
        return String(htmlEncodedString: html)
    }
    return nil
}
</code></pre>
<p>Create a method <code>getDistanceInstructions</code> that can get us information about the travelling distance. This is determined by the <code>duration</code> property of a <code>MPRouteLeg</code>. The distance is returned in meters so if you require imperial units, make a conversion.</p>
<pre><code class="language-swift">fileprivate func getDistanceInstructions(_ distance:NSNumber?) -&gt; String {
    let feet = Int((distance?.doubleValue ?? 0) * 3.28)
    return &quot;Continue for \(feet) feet&quot;
}
</code></pre>
<h2>Suggested logic for generating meaningful instructions</h2>
<p>Obviously it is up to your application to present some instructions to the end user, but here a suggestion. Add a method called <code>updateViews</code> that will fire whenever our models change.</p>
<pre><code class="language-swift">func updateViews() {
</code></pre>
<p>Initialise an array of textual instructions and check for existence of a current leg.</p>
<pre><code class="language-swift">if route.legs?.count ?? 0 &gt; 0 {
    var instructions = [String]()
    if let currentLeg = route.legs?[segment.legIndex] as? MPRouteLeg {
</code></pre>
<p>Add instructions for inside/outside as well as elevation instruction if applicable.</p>
<pre><code class="language-swift">if segment.stepIndex &gt;= 0, let currentStep = currentLeg.steps?[segment.stepIndex] as? MPRouteStep {
    if let previousStep = getPreviousStep(segment.stepIndex, segment.legIndex, route) {
        if let outsideInsideInstructions = getOutsideInsideInstructions(previousStep, currentStep) {
            instructions.append(outsideInsideInstructions)
        }
    }
    if let elevationInstructions = getElevationInstructions(currentStep) {
        instructions.append(elevationInstructions)
    }
    if let defaultInstructions = getDefaultInstructions(currentStep) {
        instructions.append(defaultInstructions)
    }
    instructions.append(getDistanceInstructions(currentStep.distance))
}
</code></pre>
<p>We need a method to parse html because the directions instructions from Google contains html.</p>
<pre><code class="language-swift">extension String {

    init?(htmlEncodedString: String) {

        guard let data = htmlEncodedString.data(using: .utf8) else {
            return nil
        }

        let options: [NSAttributedString.DocumentReadingOptionKey: Any] = [
            NSAttributedString.DocumentReadingOptionKey.documentType: NSAttributedString.DocumentType.html,
            NSAttributedString.DocumentReadingOptionKey.characterEncoding: String.Encoding.utf8.rawValue
        ]

        guard let attributedString = try? NSAttributedString(data: data, options: options, documentAttributes: nil) else {
            return nil
        }

        self.init(attributedString.string)
    }

}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Advanced%20Directions/RouteSegmentView.swift">See the sample in RouteSegmentView.swift</a></p>
<h2>Create the controller that displays generated textual instructions segment by segment</h2>
<p>We use a collection view to do this but you can of course use whatever view that fits your use case best.</p>
<p>First we will define a protocol called <code>RouteSegmentsControllerDelegate</code> that will be used to handle the selection of each represented route segment. The method <code>didSelectRouteSegment</code> will be delegating the handling of route segment selections.</p>
<pre><code class="language-swift">protocol RouteSegmentsControllerDelegate {
    func didSelectRouteSegment(segment:MPRouteSegmentPath)
}
</code></pre>
<h2>The Route Segments Controller</h2>
<p>Create a controller class called <code>RouteSegmentsController</code> that inherits from <code>UIViewController</code>.</p>
<pre><code class="language-swift">class RouteSegmentsController : UIViewController {
</code></pre>
<p>Add some properties to the controller</p>
<ul>
<li><code>startingScrollingOffset</code> We will do a side-ways scroll in the collection, so we will add a private point property to keep track of that</li>
<li><code>tableView</code> the actual table view property.</li>
<li><code>delegate</code> the delegate property.</li>
</ul>
<pre><code class="language-swift">private var startingScrollingOffset = CGPoint.zero
private var tableView:UITableView!
var delegate:RouteSegmentsControllerDelegate?
</code></pre>
<p>Add a <code>route</code> property to the class</p>
<pre><code class="language-swift">var route:MPRoute = MPRoute() {
    didSet {
        self.tableView.reloadData()
    }
}
</code></pre>
<p>Add a <code>currentSegment</code> property to the class</p>
<pre><code class="language-swift">var currentSegment:MPRouteSegmentPath = MPRouteSegmentPath() {
    didSet {
        if oldValue.legIndex != currentSegment.legIndex {
            self.tableView.reloadData()
        }
    }
}
</code></pre>
<p>Implement <code>viewDidLoad</code> method, creating the horizontal collection view and assigning delegates to the collection view. Make sure that you register your own custom <code>RouteSegmentView</code> here.</p>
<pre><code class="language-swift">override func viewDidLoad() {
    self.tableView = UITableView.init(frame: view.frame)
</code></pre>
<p>Create a method 'updateRouteSegmentSelection' that notifies the delegate</p>
<pre><code class="language-swift">func updateRouteSegmentSelection(segment: MPRouteSegmentPath) {
    delegate?.didSelectRouteSegment(segment: segment)
    currentSegment = segment
}
</code></pre>
<h2>The Route Segments Controller Data Source</h2>
<p>Create an extension of <code>RouteSegmentsController</code> that implements <code>UICollectionViewDataSource</code> protocol.</p>
<pre><code class="language-swift">extension RouteSegmentsController : UITableViewDataSource {
</code></pre>
<p>In the <code>collectionView numberOfItemsInSection</code> method, let the item count reflect the number of legs in the current route.</p>
<pre><code class="language-swift">func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    let leg = route.legs?[section] as? MPRouteLeg
    return leg?.steps?.count ?? 0
}
</code></pre>
<p>In the <code>collectionView cellForItemAt indexPath</code> method, create a segment based on the index paths row (leg) index. Dequeue a cell view and update the <code>route</code> and <code>segment</code> properties accordingly.</p>
<pre><code class="language-swift">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    let segment = MPRouteSegmentPath(legIndex: indexPath.section, stepIndex: indexPath.row)
    let tvCell:RouteSegmentView = tableView.dequeueReusableCell(withIdentifier: &quot;TVC&quot;, for: indexPath) as! RouteSegmentView
    tvCell.renderRouteInstructions(route, for: segment)
    return tvCell
}
</code></pre>
<p>In the <code>titleForHeaderInSection</code> method, return the number of legs in the current route.</p>
<pre><code class="language-swift">func numberOfSections(in tableView: UITableView) -&gt; Int {
    return route.legs?.count ?? 0
}
</code></pre>
<p>Implement the <code>heightForRowAtIndexPath</code> method.</p>
<pre><code class="language-swift">func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat {
    return 80
}
</code></pre>
<p>Optionally implement the <code>titleForHeaderInSection</code> method.</p>
<pre><code class="language-swift">func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {
    if let leg = route.legs?[section] as? MPRouteLeg {
        let meters = leg.distance?.intValue ?? 0
        return &quot;\(meters) meters&quot;
    }
    return &quot;&quot;
}
</code></pre>
<h2>Table View Delegate</h2>
<p>Create an extension of <code>RouteSegmentsController</code> that implements <code>UITableViewDelegate</code> protocol. In method <code>didSelectRowAtIndexPath</code> update the current route segment.</p>
<pre><code class="language-swift">extension RouteSegmentsController : UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        updateRouteSegmentSelection(segment: MPRouteSegmentPath(legIndex: indexPath.section, stepIndex: indexPath.row))
    }
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Advanced%20Directions/RouteSegmentsController.swift">See the sample in RouteSegmentsController.swift</a></p>
<h2>Create a controller that renders a map and utilizes interaction between a route rendered on the map and the selected instructions</h2>
<p>Start by creating a controller class <code>AdvancedDirectionsController</code> that inherits from <code>UIViewController</code></p>
<pre><code class="language-swift">class AdvancedDirectionsController: UIViewController {
</code></pre>
<p>Setup map-related member variables for <code>AdvancedDirectionsController</code>:</p>
<ul>
<li>A Google Maps <code>map</code> property</li>
<li>A MapsIndoors <code>mapControl</code> property</li>
<li>A MapsIndoors <code>renderer</code> property</li>
<li>A <code>routeVC</code> property used as a child view controller to this VC</li>
</ul>
<pre><code class="language-swift">var map: GMSMapView! = nil
var mapControl: MPMapControl! = nil
var renderer: MPDirectionsRenderer! = nil
var stepWiseRenderer: MPDirectionsRenderer! = nil
</code></pre>
<p>Setup directions related member variables for <code>AdvancedDirectionsController</code>:</p>
<ul>
<li>A <code>routeVC</code> property used as a child view controller to this VC</li>
<li>A <code>heightConstraintForRouteView</code> property that can control the visibility of the route view</li>
<li>A <code>directionsVisible</code> bool that can control the visibility of the route view by affecting the height of the route view</li>
<li>A <code>searchButton</code> that will open a search controller to choose your destination</li>
</ul>
<pre><code class="language-swift">var routeVC: RouteSegmentsController! = nil
var heightConstraintForRouteView:NSLayoutConstraint! = nil
var directionsVisible:Bool! {
    didSet {
        heightConstraintForRouteView.constant = directionsVisible ? 240 : 0
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
        }
    }
}
var searchButton:UIButton! = nil
let directions = MPDirectionsService.init()
var destinationLocation:MPLocation? {
    didSet {
        updateDirections()
        searchButton.setTitle(destinationLocation?.name, for: .normal)
    }
}
var originLocation:MPLocation?
</code></pre>
<p>Create a <code>setupMap</code> method that sets up the Google map and MapsIndoors Map Control object.</p>
<pre><code class="language-swift">fileprivate func setupMap() {
    self.map = GMSMapView.init(frame: CGRect.zero)
    self.map.camera = .camera(withLatitude: 57.057964, longitude: 9.9504112, zoom: 20)
    self.mapControl = MPMapControl.init(map: self.map!)
    view.addSubview(self.map)
}
</code></pre>
<p>Create a <code>setupSearchButton</code> method that sets up a button that can trigger the destination location selection.</p>
<pre><code class="language-swift">fileprivate func setupSearchButton() {
    searchButton = UIButton.init()
    searchButton.setTitle(&quot;Search Destination&quot;, for: .normal)
    searchButton.addTarget(self, action: #selector(selectDestination), for: .touchUpInside)
    searchButton.backgroundColor = .blue
    view.addSubview(searchButton)
}
</code></pre>
<p>Create a <code>setupConstraints</code> method that sets up all the layout constraints. In your projects you might do all this in a storyboard.</p>
<pre><code class="language-swift">fileprivate func setupConstraints() {

    map.translatesAutoresizingMaskIntoConstraints = false
    map.widthAnchor.constraint(equalTo:view.widthAnchor).isActive = true
    map.topAnchor.constraint(equalTo:view.topAnchor).isActive = true

    searchButton.translatesAutoresizingMaskIntoConstraints = false
    searchButton.heightAnchor.constraint(equalToConstant: 68).isActive = true
    searchButton.widthAnchor.constraint(equalTo:view.widthAnchor).isActive = true
    searchButton.topAnchor.constraint(equalTo: map.bottomAnchor).isActive = true

    routeVC.view.translatesAutoresizingMaskIntoConstraints = false
    routeVC.view.widthAnchor.constraint(equalTo:view.widthAnchor).isActive = true
    routeVC.view.bottomAnchor.constraint(equalTo:view.bottomAnchor).isActive = true
    routeVC.view.topAnchor.constraint(equalTo:searchButton.bottomAnchor).isActive = true

    heightConstraintForRouteView = routeVC.view.heightAnchor.constraint(equalToConstant:0)
    heightConstraintForRouteView.isActive = true
}
</code></pre>
<p>Create a <code>setupRouteNav</code> method that instantiates <code>RouteSegmentsController</code> and adds it as a child view controller. Assign this controller as its delegate.</p>
<pre><code class="language-swift">fileprivate func setupRouteNav() {
    routeVC = RouteSegmentsController.init()
    self.addChildViewController(routeVC!)
    view.addSubview(routeVC.view)
    routeVC.didMove(toParentViewController: self)
    routeVC.delegate = self as RouteSegmentsControllerDelegate
}
</code></pre>
<p>Create a <code>selectDestination</code> method that instantiates and presents <code>MySearchController</code>. Assign this controller as its delegate.</p>
<pre><code class="language-swift">@objc fileprivate func selectDestination() {
    let searchController = MySearchController.init(near: nil)
    searchController.delegate = self
    self.present(searchController, animated: true, completion: nil)
}
</code></pre>
<p>Create a <code>setupRenderer</code> method that instantiates <code>MPDirectionsRenderer</code> and adds it as a child view controller. Assign this controller as its delegate.</p>
<pre><code class="language-swift">fileprivate func setupRenderer() {
    self.renderer = MPDirectionsRenderer.init()
    self.renderer.delegate = self as MPDirectionsRendererDelegate
    self.renderer.fitBounds = true
    self.renderer.solidColor = .clear
    self.renderer.map = self.map

    self.stepWiseRenderer = MPDirectionsRenderer.init()
    self.stepWiseRenderer.fitBounds = false
    self.stepWiseRenderer.map = self.map
    self.stepWiseRenderer.nextRouteLegButton?.isHidden = true
    self.stepWiseRenderer.previousRouteLegButton?.isHidden = true
}
</code></pre>
<p>Create a <code>setOriginLocation</code> method that mocks a origin location by searching for a random venue in MapsIndoors.</p>
<pre><code class="language-swift">fileprivate func setOriginLocation() {
    let q = MPQuery()
    q.query = &quot;venue&quot;
    MPLocationService.sharedInstance().getLocationsUsing(q, filter: MPFilter()) { (locations, err) in
        if let loc = locations?.first {
            self.originLocation = loc
            self.mapControl.go(to: loc)
        }
    }
}
</code></pre>
<p>In the <code>viewDidLoad</code> put the pieces together by calling the above methods.</p>
<pre><code class="language-swift">override func viewDidLoad() {
    super.viewDidLoad()
    setupMap()
    setupSearchButton()
    setupRouteNav()
    setupRenderer()
    setupConstraints()
    setOriginLocation()
}
</code></pre>
<p>Create a <code>updateDirections</code> method that sets up a MapsIndoors directions query. Execute a query and pass the resulting route object to the renderer.</p>
<pre><code class="language-swift">fileprivate func updateDirections() {
    if let origin = originLocation, let destination = destinationLocation {
        let directionsQuery = MPDirectionsQuery.init(origin: origin, destination: destination)
        directions.routing(with: directionsQuery) { (route, error) in
            if let route = route {
                self.directionsVisible = true
                self.routeVC!.route = route
                self.renderer.route = route
                self.renderer.routeLegIndex = 0
                self.stepWiseRenderer.route = route
            }
        }
    }
}
</code></pre>
<h2>Map interactions</h2>
<p>Let's do a couple of extensions for the map interactions. First implement the <code>RouteSegmentsControllerDelegate</code> through an extension. In <code>didSelectRouteSegment</code> update the leg index for the directions renderer.</p>
<pre><code class="language-swift">extension AdvancedDirectionsController : RouteSegmentsControllerDelegate {
    func didSelectRouteSegment(segment: MPRouteSegmentPath) {
        renderer.routeLegIndex = segment.legIndex
        renderer.fitBounds = false
        stepWiseRenderer.routeLegIndex = segment.legIndex
        stepWiseRenderer.routeStepIndex = segment.stepIndex
        stepWiseRenderer.animate(3)
        stepWiseRenderer.fitBounds = true
    }
}
</code></pre>
<p>Implement the <code>MPDirectionsRendererDelegate</code> through an extension. In <code>floorDidChange</code> update the current visible floor on the map control object.</p>
<pre><code class="language-swift">extension AdvancedDirectionsController : MPDirectionsRendererDelegate {
    func floorDidChange(_ floor: NSNumber) {
        mapControl.currentFloor = floor
    }
}
</code></pre>
<p>Implement the <code>MySearchControllerDelegate</code> through an extension. In <code>didSelectLocation</code> update the <code>destinationLocation</code> property.</p>
<pre><code class="language-swift">extension AdvancedDirectionsController : MySearchControllerDelegate {
    func didSelectLocation(location: MPLocation) {
        destinationLocation = location
    }
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsIOS/blob/master/Example/DemoSamples/Advanced%20Directions/AdvancedDirectionsController.swift">See the sample in AdvancedDirectionsController.swift</a></p>

    </main>
  </body>
</html>
