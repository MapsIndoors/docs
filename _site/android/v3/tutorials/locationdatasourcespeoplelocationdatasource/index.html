<p>In this tutorial we will show how you can build a custom Location Source, representing locations of people. The people's locations will be served from a mocked list in the source and displayed on a map.</p>
<p>We will start by creating our implementation of a location source.</p>
<p>Create the class <code>PeopleLocationDataSource</code> that implements <code>MPLocationSource</code>:</p>
<pre><code class="language-java">public class PeopleLocationDataSource implements MPLocationSource {
</code></pre>
<p>First we need to predefine some attributes:</p>
<ul>
<li><code>BASE_POSITION</code>: We need a base position as a start for the Locations</li>
<li><code>RANGE_MAX_LAT_OFFSET</code>: A max latitude offset to put a limit on how far the Locations can move on the latitude axis.</li>
<li><code>RANGE_MAX_LNG_OFFSET</code>: A max longitude offset to put a limit on how far the Locations can move on the longitude axis.</li>
<li><code>LOCATIONS_COUNT</code>: The number of Locations desired</li>
<li><code>LOCATION_SOURCE_ID</code>: a unique  location source ID</li>
<li><code>LOCATION_TYPE</code>: a type for the locations of this source</li>
<li><code>LOCATION_CLUSTER_ID</code>: A cluster ID that will let locations from this source cluster together on the map in case of overlap.</li>
<li><code>DISPLAY_RULE</code>: The display rule for the locations of this source.</li>
</ul>
<pre><code class="language-java">private static final LatLng BASE_POSITION        = new LatLng( 57.0582502, 9.9504788 );
private static final double RANGE_MAX_LAT_OFFSET = 0.000626 / 4;
private static final double RANGE_MAX_LNG_OFFSET = 0.0003384 / 2;
private static final int    LOCATIONS_COUNT      = 20;
private static final int    LOCATION_SOURCE_ID   = 2000;
private static final String LOCATION_TYPE        = &quot;PeopleLocationType&quot;;
public static final int     LOCATION_CLUSTER_ID  = 1;
static final LocationDisplayRule DISPLAY_RULE = new LocationDisplayRule.Builder( LOCATION_TYPE ).
        setBitmapDrawableIcon( R.drawable.generic_user ).
        setVisible( true ).
        setShowLabel( false ).
        setZoomLevelOn( 18 ).
        setLocationClusterId( LOCATION_CLUSTER_ID ).
        setDisplayRank( 1 ).
        build();
// People avatar icons
@DrawableRes
private final int[] peopleAvatars = new int[]{
        R.drawable.ic_avatar_1,
        R.drawable.ic_avatar_2,
        R.drawable.ic_avatar_3,
        R.drawable.ic_avatar_4,
        R.drawable.ic_avatar_5
};
</code></pre>
<p>Then we need to add some variables:</p>
<ul>
<li><code>observers</code>: We need a base position as a start for the Locations.</li>
<li><code>locationsList</code>: A max latitude offset to put a limit on how far the Locations can move on the latitude axis.</li>
<li><code>status</code>: holds the status of the location data source.</li>
<li><code>mDataUpdateTimer</code>: Timer that we will need to plan some recurrent updates.</li>
<li><code>dynamicLocations</code>: a List of DynaLocations that will carry the dynamic side of the locations.</li>
<li><code>random</code>: used to generate some random values in the data creation and editing.</li>
</ul>
<pre><code class="language-java">@NonNull
private List&lt;MPLocationsObserver&gt; observers;
private List&lt;MPLocation&gt; locationsList;
private MPLocationSourceStatus status;
private Timer mDataUpdateTimer;
private List&lt;DynaLocation&gt; dynamicLocations;
private Random random = new Random();
</code></pre>
<p>Create the DynaLocation class that represents the moving Locations with a position and a heading:</p>
<pre><code class="language-java">class DynaLocation
{
    LatLng pos;
    double heading;
    DynaLocation( @NonNull LatLng pos, double heading )
    {
        this.pos = pos;
        this.heading = heading;
    }
}
PeopleLocationDataSource() {
    this.locationsList = new ArrayList&lt;&gt;( LOCATIONS_COUNT );
    this.observers = new ArrayList&lt;&gt;();
    this.status = MPLocationSourceStatus.NOT_INITIALIZED;
}
</code></pre>
<p>Create the <code>startUpdatingPositions</code> method that simply calls <code>updateLocations</code> every second:</p>
<pre><code class="language-java">void startUpdatingPositions() {
    if (!setup()) {
        return;
    }
    if (mDataUpdateTimer != null) {
        mDataUpdateTimer.cancel();
        mDataUpdateTimer = null;
    }
    mDataUpdateTimer = new Timer();
    mDataUpdateTimer.scheduleAtFixedRate( new TimerTask() {
        @Override
        public void run() {
            updateLocations();
        }
    }, 2000, 1000 );
}
</code></pre>
<p>Create a method that can stop the positions updates at any time:</p>
<pre><code class="language-java">void stopUpdatingPositions() {
    if (mDataUpdateTimer != null) {
        mDataUpdateTimer.cancel();
        mDataUpdateTimer.purge();
    }
}
</code></pre>
<p>Create a method called <code>setup</code> that will:</p>
<ul>
<li>Make sure that the data source was not already initialized and data is loaded.</li>
<li>Create the locations.</li>
<li>Make the first notification.</li>
<li>Change the status to available</li>
</ul>
<pre><code class="language-java">private boolean setup()
{
    if( this.status != MPLocationSourceStatus.NOT_INITIALIZED ) {
        return true;
    }
    final BuildingCollection buildingCollection = MapsIndoors.getBuildings();
    final boolean gotBuildings = buildingCollection != null;
    if (!gotBuildings) {
        return false;
    }
    locationsList.clear();
    locationsList.addAll( generateLocations( false ) );
    notifyUpdateLocations( locationsList );
    setStatus( MPLocationSourceStatus.AVAILABLE );
    return true;
}
</code></pre>
<p>Create a method called <code>updateLocations</code> that will update the position of the Locations:</p>
<pre><code class="language-java">void updateLocations() {
    // make sure that that the MapsIndoors is ready and that everything is well set
    if (!MapsIndoors.isReady()) {
        return;
    }
    // Create a list where we are gonna put the updated locations
    final List&lt;MPLocation&gt; updatedList = new ArrayList&lt;&gt;();
    // First time, generate info
    final int locationListSize = locationsList.size();
    if ((dynamicLocations == null) &amp;&amp; (locationListSize &gt; 0)) {
        dynamicLocations = new ArrayList&lt;&gt;(locationListSize);
        for (int i = 0; i &lt; locationListSize; i++) {
            final MPLocation Location = locationsList.get(i);
            double ang = (i * 10.0) % 360.0;
            dynamicLocations.add(i, new DynaLocation(Location.getLatLng(), ang));
        }
    }
    for (int i = 0, LocationCount = locationsList.size(); i &lt; LocationCount; i++) {
        final MPLocation p = locationsList.get(i);
        // &quot;Update&quot; a Location MPLocation by using the copy/edit builder
        final MPLocation.Builder updatedLoc = new MPLocation.Builder(p);
        final DynaLocation dp = dynamicLocations.get(i);
        final LatLng dpOldPos = dp.pos;
        double newHeading = dp.heading;
        LatLng newPos = SphericalUtil.computeOffset(dpOldPos, 2, dp.heading);
        // Check limits, if the new position is outside the limit, then we will generate a new heading and calculate a new offset
        if ((Math.abs(BASE_POSITION.latitude - newPos.latitude) &gt; RANGE_MAX_LAT_OFFSET) ||
                (Math.abs(BASE_POSITION.longitude - newPos.longitude) &gt; RANGE_MAX_LNG_OFFSET)) {
            newHeading += (180.0 + (random.nextInt() * 15));
            newHeading = newHeading % 360;
            newPos = SphericalUtil.computeOffset(newPos, 1, newHeading);
        }
        dp.pos = newPos;
        dp.heading = newHeading;
        // set the new position with an animation time
        updatedLoc.setPosition(dp.pos, 1000);
        // Add the updated Location to the updatedLoc list
        updatedList.add(updatedLoc.build());
    }
    // Update the current locations list
    locationsList.clear();
    locationsList.addAll(updatedList);
    // Give a notification
    notifyUpdateLocations(updatedList);
}
</code></pre>
<p>Create a method called <code>generateLocations</code>. Iterate numberOfPeople and for each iteration create:</p>
<ul>
<li>An MPLocation Builder with an id</li>
<li>A random position according to the 'randomizeStartingPosition' parameter</li>
<li>A name</li>
<li>A type - later used to style the location</li>
<li>A floor Index</li>
<li>A building</li>
</ul>
<pre><code class="language-java">@NonNull
private List&lt;MPLocation&gt; generateLocations( boolean randomizeStartingPosition )
{
    final List&lt;MPLocation&gt; peopleLocations = new ArrayList&lt;&gt;( LOCATIONS_COUNT );
    final BuildingCollection buildingCollection = MapsIndoors.getBuildings();
    final boolean gotBuildingData = buildingCollection != null;
    final int avatarIconsCount = peopleAvatars.length;
    int avatarCurrentIndex = 0;
    for ( int i = 0; i &lt; LOCATIONS_COUNT; i++) {
        final String personName = getPersonName();
        final LatLng personPosition;
        if (randomizeStartingPosition) {
            personPosition = getRandomPosition();
        } else {
            personPosition = BASE_POSITION;
        }
        final MPLocation.Builder locBuilder = new MPLocation.Builder(&quot;&quot;+ LOCATION_SOURCE_ID + i);
        locBuilder.setPosition(personPosition).
                setName(personName).
                setType( LOCATION_TYPE );
        // give an icon to the Location
        final @DrawableRes int currentAvatarIcon = peopleAvatars[avatarCurrentIndex];
        avatarCurrentIndex = (avatarCurrentIndex + 1) % avatarIconsCount;
        locBuilder.setVectorDrawableIcon(currentAvatarIcon, 32, 32);
        if (gotBuildingData) {
            // Find a building at this location (personPosition)
            final Building building = buildingCollection.getBuilding(personPosition);
            if (building != null) {
                // Building found at this location, get the list of floors in it
                final List&lt;Floor&gt; floors = building.getFloors();
                // Choose a random floor
                final Floor floor = floors.get((int) (Math.random() * (floors.size())));
                // Set the Location floor
                locBuilder.setFloor((floor != null) ? floor.getZIndex() : Floor.DEFAULT_GROUND_FLOOR_INDEX);
                // Set the building name where this Location is in
                locBuilder.setBuilding(building.getName());
            } else {
                // If this location was outside a building, set its floor/z index to zero (ground floor)
                locBuilder.setFloor(Floor.DEFAULT_GROUND_FLOOR_INDEX);
            }
        } else {
            // If this location was outside a building, set its floor/z index to zero (ground floor)
            locBuilder.setFloor(Floor.DEFAULT_GROUND_FLOOR_INDEX);
        }
        peopleLocations.add(locBuilder.build());
    }
    return peopleLocations;
}
</code></pre>
<p>Create a method called <code>getPersonName</code> that simply just returns a random name selected from the arrays below:</p>
<pre><code class="language-java">// lists of names and last names
private final String[] FIRST_NAMES = {&quot;John&quot;, &quot;Joe&quot;, &quot;Javier&quot;, &quot;Mike&quot;, &quot;Janet&quot;, &quot;Susan&quot;, &quot;Cristina&quot;, &quot;Michelle&quot;};
private final String[] LAST_NAMES = {&quot;Smith&quot;, &quot;Jones&quot;, &quot;Andersson&quot;, &quot;Perry&quot;, &quot;Brown&quot;, &quot;Hill&quot;, &quot;Moore&quot;, &quot;Baker&quot;};
private String getPersonName() {
    final int firstNameIndex = random.nextInt(FIRST_NAMES.length);
    final int lastNameIndex = random.nextInt(LAST_NAMES.length);
    return String.format(&quot;%1s %2s&quot;, FIRST_NAMES[firstNameIndex], LAST_NAMES[lastNameIndex]);
}
</code></pre>
<p>Create a method called <code>getRandomPosition</code> that simply just returns a random LatLng (here within proximity of the demo venue):</p>
<pre><code class="language-java">private LatLng getRandomPosition() {
    final double lat = BASE_POSITION.latitude + (-4 + random.nextInt(20)) * 0.000005;
    final double lng = BASE_POSITION.longitude + (-4 + random.nextInt(20)) * 0.000010;
    return new LatLng(lat, lng);
}
</code></pre>
<p>Create a method called <code>notifyUpdateLocations</code> to loop all the observers and notify them with an update:</p>
<pre><code class="language-java">private void notifyUpdateLocations(List&lt;MPLocation&gt; updatedLocations) {
    for (int i = observers.size(); --i &gt;= 0; ) {
        observers.get(i).onLocationsUpdated(updatedLocations, this);
    }
}
</code></pre>
<p>The same thing for notifying observers with new status. Create a method called <code>notifyLocationStatusChanged</code> to loop all the observers and notify them with a status change:</p>
<pre><code class="language-java">private void notifyLocationStatusChanged(@NonNull MPLocationSourceStatus prevStatus, @NonNull MPLocationSourceStatus newStatus) {
    for (int i = observers.size(); --i &gt;= 0; ) {
        observers.get(i).onStatusChanged(newStatus, this);
    }
}
</code></pre>
<p>Sets the internal state and notifies a status changed message if applies:</p>
<pre><code class="language-java">private void setStatus(@NonNull MPLocationSourceStatus newStatus) {
    MPLocationSourceStatus cStatus = status;
    if (cStatus != newStatus) {
        status = newStatus;
        notifyLocationStatusChanged(cStatus, newStatus);
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>getLocations</code>:</p>
<pre><code class="language-java">@NonNull
@Override
public List&lt;MPLocation&gt; getLocations() {
    return locationsList;
}
</code></pre>
<p>Implement the MPLocationSource method <code>addLocationObserver</code>:</p>
<pre><code class="language-java">@Override
public void addLocationsObserver(@Nullable MPLocationsObserver observer) {
    if (observer != null) {
        observers.remove(observer);
        observers.add(observer);
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>removeLocationObserver</code>:</p>
<pre><code class="language-java">@Override
public void removeLocationsObserver(@Nullable MPLocationsObserver observer) {
    if (observer != null) {
        observers.remove(observer);
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>getStatus</code>:</p>
<pre><code class="language-java">@NonNull
@Override
public MPLocationSourceStatus getStatus() {
    return status;
}
</code></pre>
<p>Implement the MPLocationSource method <code>getSourceId</code>:</p>
<pre><code class="language-java">@Override
public int getSourceId() {
    return LOCATION_SOURCE_ID;
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsAndroid-Demo-Samples/blob/master/app/src/main/java/com/mapsindoors/locationdatasources/PeopleLocationDataSource.java">See the sample in PeopleLocationDataSource.java</a></p>
