<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="/assets/style.css">
    <title>Document</title>
  </head>
  <body>
    <section class="container">
      
  <nav>
    <h2>Android v3</h2>
    
    <ul class="sidebar-nav"><li class="bold"><a href="/android/v3/guides/">Guides</a><ul><li><a href="/android/v3/tutorials/locationdatasourcespeoplelocationdatasource/">Creating your own Location Data Source - Part 1</a></li>
<li class="active"><a href="/android/v3/tutorials/locationdatasourcesbatterieslocationdatasource/">Creating your own Location Data Source - Part 2</a></li>
<li><a href="/android/v3/tutorials/locationdatasourceslocationdatasourcesfragment/">Creating your own Location Data Source - Part 3</a></li>
<li><a href="/android/v3/tutorials/locationclusteringlocationclusteringfragment/">Work with location grouping / clustering</a></li>
<li><a href="/android/v3/tutorials/locationdetailsdemolocationdetailsfragment/">Show Location Details</a></li>
<li><a href="/android/v3/tutorials/searchmapdemosearchfragment/">Create a Search Experience with MapsIndoors - Part 1</a></li>
<li><a href="/android/v3/tutorials/searchmapdemosearchmapfragment/">Create a Search Experience with MapsIndoors - Part 2</a></li>
<li><a href="/android/v3/tutorials/showuserlocationdemopositionprovider/">Show the Blue Dot with MapsIndoors - Part 1</a></li>
<li><a href="/android/v3/tutorials/showuserlocationshowuserlocationfragment/">Show the Blue Dot with MapsIndoors - Part 2</a></li></ul></li>
<li><a href="/android/v3/changelog/">Changelog</a></li></ul>
  </nav>

      <main>
        <p>In this tutorial we will show how you can build a custom Location Source. In <a href="../locationdatasourcespeoplelocationdatasource">Part 1</a> we created a people location source that mocks locations of people.</p>
<p>Now we will create another location source that represents batteries. The power level of the batteries will be changing over time and it needs to be visible on the map realtime.</p>
<p>We will start by creating our implementation of a location source.</p>
<p>Create the class <code>BatteriesLocationDataSource</code> that implements <code>MPLocationSource</code>:</p>
<pre><code class="language-java">public class BatteriesLocationDataSource implements MPLocationSource {
</code></pre>
<p>First we need to predefine some attributes:</p>
<ul>
<li><code>BASE_POSITION</code>: We need a base position as a start for the Locations.</li>
<li><code>LOCATIONS_COUNT</code>: The number of locations desired.</li>
<li><code>LOCATION_SOURCE_ID</code>: a unique  location source ID.</li>
<li><code>LOCATION_TYPE</code>: a type for the locations of this source.</li>
<li><code>LOCATION_CLUSTER_ID</code>: A cluster ID that will let locations from this source cluster together on the map in case of overlap.</li>
<li><code>DISPLAY_RULE</code>: The display rule for the locations of this source.</li>
</ul>
<pre><code class="language-java">private static final LatLng BASE_POSITION       = new LatLng( 57.0579814, 9.9504668 );
private static final int    LOCATIONS_COUNT     = 20;
private static final int    LOCATION_SOURCE_ID  = 10000;
private static final String LOCATION_TYPE       = &quot;BatteryLocationType&quot;;
private static final int    LOCATION_CLUSTER_ID = 2;
static final LocationDisplayRule DISPLAY_RULE = new LocationDisplayRule.Builder( LOCATION_TYPE ).
        setVectorDrawableIcon( R.drawable.ic_battery_60_black_24dp ).
        setVisible( true ).
        setShowLabel( false ).
        setZoomLevelOn( 16 ).
        setLocationClusterId( LOCATION_CLUSTER_ID ).
        setDisplayRank( 1 ).
        build();
</code></pre>
<p>Then we need to add some variables:</p>
<ul>
<li><code>observers</code>: The observer objects that we will notify about changes.</li>
<li><code>locationsList</code>: A list of MPLocation - Will have the list of the MPLocations up to date.</li>
<li><code>status</code>: holds the status of the location data source.</li>
<li><code>random</code>: Used to generate some random values in the data creation and editing.</li>
<li><code>mDataUpdateTimer</code>: Timer that we will need to plan some recurrent updates.</li>
<li><code>iconCurrentIndex</code>: An index for icons so we can update the locations with
the same icon each time.</li>
</ul>
<pre><code class="language-java">@NonNull
private List&lt;MPLocationsObserver&gt; observers;
private List&lt;MPLocation&gt; locationsList;
private MPLocationSourceStatus status;
private Random random = new Random();
private Timer mDataUpdateTimer;
private int iconCurrentIndex = 0;
BatteriesLocationDataSource() {
    this.locationsList = new ArrayList&lt;&gt;( LOCATIONS_COUNT );
    this.observers = new ArrayList&lt;&gt;();
    this.status = MPLocationSourceStatus.NOT_INITIALIZED;
}
</code></pre>
<p>Create the <code>startUpdatingIcons</code> method that simply calls <code>updateLocations</code> every half a second.</p>
<pre><code class="language-java">void startUpdatingIcons() {
    if (!setup()) {
        return;
    }
    if (mDataUpdateTimer != null) {
        mDataUpdateTimer.cancel();
        mDataUpdateTimer = null;
    }
    mDataUpdateTimer = new Timer();
    mDataUpdateTimer.scheduleAtFixedRate(new TimerTask() {
        @Override
        public void run() {
            updateLocations();
        }
    }, 2000, 500 );
}
</code></pre>
<p>Create a method that can stop the icons update at any time.</p>
<pre><code class="language-java">void stopUpdatingIcons() {
    if (mDataUpdateTimer != null) {
        mDataUpdateTimer.cancel();
        mDataUpdateTimer.purge();
    }
}
</code></pre>
<p>Create a method called <code>setup</code> that will:</p>
<ul>
<li>Make sure that data source was not already initialized and data is loaded.</li>
<li>Create the locations.</li>
<li>Make the first notification.</li>
<li>Change the status to available.</li>
</ul>
<pre><code class="language-java">private boolean setup()
{
    if( this.status != MPLocationSourceStatus.NOT_INITIALIZED ) {
        return true;
    }
    final BuildingCollection buildingCollection = MapsIndoors.getBuildings();
    final boolean gotBuildings = buildingCollection != null;
    if( !gotBuildings ) {
        return false;
    }
    locationsList.clear();
    locationsList.addAll( generateLocations( true ) );
    notifyUpdateLocations( locationsList );
    setStatus( MPLocationSourceStatus.AVAILABLE );
    return true;
}
// Icons
@DrawableRes
final int[] icons = new int[]{
        R.drawable.ic_battery_20_black_24dp,
        R.drawable.ic_battery_30_black_24dp,
        R.drawable.ic_battery_50_black_24dp,
        R.drawable.ic_battery_60_black_24dp,
        R.drawable.ic_battery_80_black_24dp,
        R.drawable.ic_battery_90_black_24dp,
        R.drawable.ic_battery_full_black_24dp
};
</code></pre>
<p>Create a method called <code>updateLocations</code>. Iterate number again and for each iteration:</p>
<ul>
<li>Get the corresponding MPLocation Builder</li>
<li>Set a new position</li>
<li>Generate an MPLocation from a MPLocation.Builder</li>
<li>Call the notifyUpdateLocations with the updated list.</li>
</ul>
<pre><code class="language-java">void updateLocations() {
    if (!MapsIndoors.isReady()) {
        return;
    }
    final int locCount = locationsList.size();
    final List&lt;MPLocation&gt; updatedList = new ArrayList&lt;&gt;(locCount);
    int iColor = 0;
    @DrawableRes int currentIcon = 0;
    // Icon and tint color (animated)
    final int availableIconsCount = icons.length;
    // the color tint will vary
    iColor = ColorUtils.blendARGB(0xff2DD855, 0xffFF3700, ((1f * iconCurrentIndex) / availableIconsCount));
    currentIcon = icons[iconCurrentIndex];
    iconCurrentIndex = (iconCurrentIndex + 1) % availableIconsCount;
    for (int i = 0, LocationCount = locationsList.size(); i &lt; LocationCount; i++) {
        final MPLocation p = locationsList.get( i );
        // &quot;Update&quot; an MPLocation by using the copy/edit builder
        final MPLocation.Builder updatedLocation = new MPLocation.Builder( p );
        // Change the icon &amp; tint color
        updatedLocation.
                // Specify a size
                setVectorDrawableIcon( currentIcon, 32, 32 ).
                // Specify the tint color
                setTint( iColor );
        updatedList.add( updatedLocation.build() );
    }
    locationsList.clear();
    locationsList.addAll( updatedList );
    notifyUpdateLocations( updatedList );
}
</code></pre>
<p>Create a method called <code>generateLocations</code>:</p>
<ul>
<li>An MPLocation.Builder with an id</li>
<li>A random position</li>
<li>A name</li>
<li>A type - later used to style the location</li>
<li>A floor Index</li>
<li>A building</li>
</ul>
<pre><code class="language-java">@NonNull
private List&lt;MPLocation&gt; generateLocations( boolean randomizeStartingPosition )
{
    final List&lt;MPLocation&gt; peopleLocations = new ArrayList&lt;&gt;( LOCATIONS_COUNT );
    final BuildingCollection buildingCollection = MapsIndoors.getBuildings();
    final boolean gotBuildingData = buildingCollection != null;
    for ( int i = 0; i &lt; LOCATIONS_COUNT; i++) {
        final LatLng personPosition;
        if (randomizeStartingPosition) {
            personPosition = getRandomPosition();
        } else {
            personPosition = BASE_POSITION;
        }
        final MPLocation.Builder locBuilder = new MPLocation.Builder( &quot;&quot; + LOCATION_SOURCE_ID + i );
        locBuilder.setPosition( personPosition ).
                setName( &quot;Battery&quot; + i ).
                setType( LOCATION_TYPE );
        if (gotBuildingData) {
            // Find a building at this location (personPosition)
            final Building building = buildingCollection.getBuilding(personPosition);
            if (building != null) {
                // Building found at this location, get the list of floors in it
                final List&lt;Floor&gt; floors = building.getFloors();
                // Choose a random floor
                final Floor floor = floors.get((int) (Math.random() * (floors.size())));
                // Set the Location floor
                locBuilder.setFloor((floor != null) ? floor.getZIndex() : Floor.DEFAULT_GROUND_FLOOR_INDEX);
                // Set the building name where this Location is in
                locBuilder.setBuilding( building.getName() );
            } else {
                // If this location was outside a building, set its floor/z index to zero (ground floor)
                locBuilder.setFloor( Floor.DEFAULT_GROUND_FLOOR_INDEX );
            }
        } else {
            // If this location was outside a building, set its floor/z index to zero (ground floor)
            locBuilder.setFloor( Floor.DEFAULT_GROUND_FLOOR_INDEX );
        }
        peopleLocations.add( locBuilder.build() );
    }
    return peopleLocations;
}
</code></pre>
<p>Create a method called <code>getRandomPosition</code> that simply returns a random LatLng (here within proximity of the demo venue):</p>
<pre><code class="language-java">private LatLng getRandomPosition() {
    final double lat = BASE_POSITION.latitude + (-4 + random.nextInt(20)) * 0.000005;
    final double lng = BASE_POSITION.longitude + (-4 + random.nextInt(20)) * 0.000010;
    return new LatLng(lat, lng);
}
</code></pre>
<p>Create a method called <code>notifyUpdateLocations</code> to loop all the observers and notify them with an update:</p>
<pre><code class="language-java">private void notifyUpdateLocations( List&lt;MPLocation&gt; updatedLocations ) {
    for( int i = observers.size(); --i &gt;= 0; ) {
        observers.get( i ).onLocationsUpdated( updatedLocations, this );
    }
}
</code></pre>
<p>The same thing for notifying observers with new status</p>
<pre><code class="language-java">private void notifyLocationStatusChanged( @NonNull MPLocationSourceStatus prevStatus, @NonNull MPLocationSourceStatus newStatus ) {
    for( int i = observers.size(); --i &gt;= 0; ) {
        observers.get( i ).onStatusChanged( newStatus, this );
    }
}
</code></pre>
<p>Sets the internal state and notifies a status changed message if applies:</p>
<pre><code class="language-java">private void setStatus( @NonNull MPLocationSourceStatus newStatus ) {
    MPLocationSourceStatus cStatus = status;
    if (cStatus != newStatus) {
        status = newStatus;
        notifyLocationStatusChanged( cStatus, newStatus );
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>getLocations</code>. This List will always contain the up to date MPLocations:</p>
<pre><code class="language-java">@NonNull
@Override
public List&lt;MPLocation&gt; getLocations() {
    return locationsList;
}
</code></pre>
<p>Implement the MPLocationSource method <code>addLocationObserver</code>:</p>
<pre><code class="language-java">@Override
public void addLocationsObserver(@Nullable MPLocationsObserver observer) {
    if (observer != null) {
        observers.remove(observer);
        observers.add(observer);
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>removeLocationObserver</code>:</p>
<pre><code class="language-java">@Override
public void removeLocationsObserver(@Nullable MPLocationsObserver observer) {
    if (observer != null) {
        observers.remove(observer);
    }
}
</code></pre>
<p>Implement the MPLocationSource method <code>getStatus</code>:</p>
<pre><code class="language-java">@NonNull
@Override
public MPLocationSourceStatus getStatus() {
    return status;
}
</code></pre>
<p>Implement the MPLocationSource method <code>getSourceId</code>:</p>
<pre><code class="language-java">@Override
public int getSourceId() {
    return LOCATION_SOURCE_ID;
}
</code></pre>
<p><a href="https://github.com/MapsIndoors/MapsIndoorsAndroid-Demo-Samples/blob/master/app/src/main/java/com/mapsindoors/locationdatasources/BatteriesLocationDataSource.java">See the sample in BatteriesLocationDataSource.java</a></p>

      </main>
    </section>
  </body>
</html>
